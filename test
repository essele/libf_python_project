#!/usr/bin/python3

from bokeh.plotting import figure, show
from collections import OrderedDict
from math import nan
import csv
import string

#
# Helper function to convert from a KiCAD dimension (string) to
# a float value in mm
#
def kicad_num(v):
    return(float(v)/1000000.0)


#
# Helper function to return the reference type from the given reference
#
# Could have used regex, but this seemed more efficient?
#
def reftype(s):
    for i, c in enumerate(s):
        if (c.isdigit()):
            return s[:i]
    return s


class Shape():
    
    def __init__(self):
        self.minx = -1
        self.miny = -1
        self.xlist = []
        self.ylist = []

    def addPoint(self, x, y):
        if (self.minx < 0 or x < self.minx):
            self.minx = x
        if (self.miny < 0 or y < self.miny):
            self.miny = y
        self.xlist.append(x)
        self.ylist.append(y)

    def shiftByAmount(self, movex, movey):
        for index, x in enumerate(self.xlist):
            self.xlist[index] = x - movex;
        for index, y in enumerate(self.ylist):
            self.ylist[index] = y - movey;
        
    def shiftToZero(self):
        self.shiftByAmount(self.minx, self.miny)

    def draw(self, plot, **kwargs):
        p.patch(self.xlist + [self.xlist[0]], self.ylist + [self.ylist[0]], **kwargs)
        

class Component():
    def __init__(self, board, fields):
        
        # Some handy references for future drawing
        self.width = kicad_num(fields["right"]) - kicad_num(fields["left"])
        self.height = kicad_num(fields["bottom"]) - kicad_num(fields["top"])
        self.originx = kicad_num(fields["left"]) - board.minx;
        self.originy = kicad_num(fields["top"]) - board.miny

    def getName(self):
        return type(self).__name__

    #
    # Re-implementation of the block function so we can use percentages...
    #
    def block(self, p, x, y, w, h, **kwargs):
        p.block(x=self.originx + (self.width*x), y=self.originy + (self.height*y),
                width=self.width*w, height=self.height*h, **kwargs)

    # 
    # Same for line... supporting multiple values
    #
    def line(self, p, x, y, **kwargs):
        # Wanted to use map/lambda here, but got very weird errors
        for i, xx in enumerate(x):
            x[i] = self.originx + (self.width * xx)
        for i, yy in enumerate(y):
            y[i] = self.originy + (self.height * yy)
        p.line(x, y, **kwargs)

    #
    # And same for ellipse [circle] (just support one)
    #
    def circle(self, plot, dia, **kwargs):
        mindim = min(self.width, self.height)
        plot.ellipse(x=self.originx+(self.width*0.5), y=self.originy+(self.height*0.5),
            width=mindim*dia, height=mindim*dia, **kwargs)
        

    def draw(self, plot):
        self.block(plot, 0, 0, 1, 1, line_color="#dddddd", fill_alpha=0.0, line_alpha=0.5, line_dash="dotted")


class Unknown(Component):
    def draw(self, plot):
        super().draw(plot)

        # Used fixed (not relative) gap for this one...
        gap = 0.2
        plot.block(x=self.originx+gap, y=self.originy+gap, width=self.width-(gap*2), height=self.height-(gap*2),
                    hatch_color="green", hatch_pattern="diagonal_cross", hatch_weight=1, 
                    fill_alpha=0.0, line_alpha=0.0, hatch_scale=8)


class Resistor(Component):
    def draw(self, plot):
        super().draw(plot)

        self.line(plot, 
                    [0.1, 0.3, 0.3, 0.7, 0.7, 0.9, nan, 0.7, 0.7, 0.3, 0.3],
                    [0.5, 0.5, 0.2, 0.2, 0.5, 0.5, nan, 0.5, 0.8, 0.8, 0.5],
                    color="yellow", line_width=1)

class Capacitor(Component):
    def draw(self, plot):
        super().draw(plot)


        self.line(plot, 
                    [0.1, 0.4, nan, 0.4, 0.4, nan, 0.6, 0.6, nan, 0.6, 0.9],
                    [0.5, 0.5, nan, 0.2, 0.8, nan, 0.2, 0.8, nan, 0.5, 0.5],
                    color="yellow", line_width=1)


class Transistor(Component):
    def draw(self, plot):
        super().draw(plot)

        self.circle(plot, 0.9, color="yellow", line_width=1);

class IC(Component):
    def draw(self, plot):
        super().draw(plot)

        xx = [ 0.3, 0.7, 0.7, 0.3, 0.3, nan ];      # Main box
        yy = [ 0.2, 0.2, 0.8, 0.8, 0.2, nan ];      # Main box
        for i in [ 0.3, 0.4, 0.5, 0.6, 0.7 ]:       # Add legs to both sides
            xx += [ 0.1, 0.3, nan ];
            yy += [ i, i, nan ];
            xx += [ 0.7, 0.9, nan ];
            yy += [ i, i, nan ];

        self.line(plot, xx, yy, color="yellow", line_width=1)


class Diode(Component):
    def draw(self, plot):
        super().draw(plot)

        self.line(plot,
                    [0.1, 0.3, 0.3, 0.7, 0.3, 0.3, nan, 0.7, 0.7, nan, 0.7, 0.9], 
                    [0.5, 0.5, 0.3, 0.5, 0.7, 0.5, nan, 0.3, 0.7, nan, 0.5, 0.5],
                    color="yellow", line_width=1)


mapping = { "FB": Unknown, "R": Resistor, "C": Capacitor, "Q": Transistor, "U": IC, "D": Diode }



#
# MAIN FROM HERE
#

board = Shape()
with open("/home/essele/kicad/sample/board.csv") as bfile:
    reader = csv.DictReader(bfile)
    for row in reader:
        print("XX: " + row["x"] + " -- " + row["y"])
        board.addPoint(kicad_num(row["x"]), kicad_num(row["y"]))

    board.shiftToZero()

#
# Draw the board outline...
#

# create a new plot with a title and axis labels
p = figure(title="PCB layout", x_axis_label="x (mm)", y_axis_label="y (mm)", match_aspect=True)
board.draw(p, line_width=2, fill_color="#002d04", line_color="black")
#p.line(board.xlist, board.ylist, legend_label="Board Outline", line_width=2)

#
# Now run through the components...
#
with open("/home/essele/kicad/sample/components.csv") as cfile:
    reader = csv.DictReader(cfile)
    for row in reader:
        rt = reftype(row["ref"]);

        map = mapping.get(rt, Unknown)
        print("Map is")
        print(map)
        c = map(board, row)
        c.draw(p)



# show the results
show(p)
